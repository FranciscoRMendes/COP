{
well.temp <- read.csv(file,stringsAsFactors = FALSE, header = F , skip =1) %>% f.make.names
well.temp <- well.temp[grep(cols.keep.str,names(well.temp))]
names(well.temp)[grep('PROD.FLOWLINE.PRES|INJ.PRES',names(well.temp))] <- 'WELL.PROD.FLOWLINE.PRES'
names(well.temp)[grep('PROD.FLOWLINE.TEMP|INJ.TEMP',names(well.temp))] <- 'WELL.PROD.FLOWLINE.TEMP'
well.id <- basename(file) %>%  gsub('(^.+_)(\\d+)(_.+$)', '\\2',.) %>% as.numeric
well.temp$WELL.ID <- well.id
d.well <- dplyr:: bind_rows(d.well, well.temp)
}
}
d.well[,-1] <- sapply(d.well[,-1], as.numeric)
d.mpm.tsep.well <- left_join(d.mpm.tsep, d.well, by=c('DATE.TIME','WELL.ID'))
d.mpm.tsep.well <- unique(d.mpm.tsep.well) # remove duplicated rows
## well data may be missing for some dates for which  mpm and test data are available,
## get a joined file with complete rows only
d.mpm.tsep.well.complete <- d.mpm.tsep.well[complete.cases(d.mpm.tsep.well),]
saveRDS(d.mpm.tsep.well, 'Generated_R_data/d.mpm.tsep.well.rds')
saveRDS(d.mpm.tsep.well.complete, 'Generated_R_data/d.mpm.tsep.well.complete.rds')
require(R.matlab)
require(stringr)
require(dplyr)
require(lubridate)
require(glmnet)
require(ggplot2)
require(data.table)
require(zoo) # for rollmean
require(beepr)
# source('f.loess.r')
# source('f.reg.well.out.r')
source('f.measure.error.r')
source('clip.r') #change this function
# test<-filter(d.reg, DATE.TIME %within% interval('2016-10-06 11:00:00','2016-10-07 8:20:00'  ))
# plot(test$TSEP.PD.STD.OIL.FLOW.RATE,type='l')
d.reg<-readRDS('d.reg.moments.rds')
nrow(d.reg)
###################
#read in data here#
###################
d.reg<-readRDS('d.reg.moments.rds')
nrow(d.reg)
###################
#DATA EDITING#
###################
df<-d.reg
for(i in 1:length(beg.time))
{
df<- filter(df, !DATE.TIME %within% interval(beg.time[i], time[i] ))
print(i)
}
d.reg<-df
#REMOVE ALL BAD TESTS FROM TSEP
test.qlty<-read.csv("C:/Users/frmendes/Desktop/Conoco Phillps/Meter Data/well_test2.csv")
time<-strptime(test.qlty$DATETIME_TEST,format ="%d%b%Y:%T" )
beg.time<-time - test.qlty$TEST_LENGTH*60*60
df<-d.reg
###################
#read in data here#
###################
d.reg<-readRDS('d.reg.moments.rds')
nrow(d.reg)
###################
#DATA EDITING#
###################
# #REMOVE ALL BAD TESTS FROM TSEP (We do not use this for now!)
# test.qlty<-read.csv("C:/Users/frmendes/Desktop/Conoco Phillps/Meter Data/well_test2.csv")
# time<-strptime(test.qlty$DATETIME_TEST,format ="%d%b%Y:%T" )
# beg.time<-time - test.qlty$TEST_LENGTH*60*60
#
# df<-d.reg
# for(i in 1:length(beg.time))
# {
#   df<- filter(df, !DATE.TIME %within% interval(beg.time[i], time[i] ))
#   print(i)
# }
# d.reg<-df
#Remove Oct 6th and 7th#########
nrow(d.reg)
d.reg<-filter(d.reg, !DATE.TIME %within% interval('2016-10-06 11:00:00','2016-10-07 8:20:00'  ))
nrow(d.reg)
#Remove Oct 6th and 7th#########
nrow(d.reg)
d.reg<-filter(d.reg, !DATE.TIME %within% interval('2016-10-06 11:00:00','2016-10-07 8:20:00'  ))
print(paste0("We have removed:", org.nrow-nrow(d.reg)))
org.nrow<-nrow(d.reg)
nrow(d.reg)
print(paste0("We have removed:", org.nrow-nrow(d.reg)))
d.reg<-readRDS('d.reg.moments.rds')
org.nrow<-nrow(d.reg)
nrow(d.reg)
###################
#DATA EDITING#
###################
# #REMOVE ALL BAD TESTS FROM TSEP (We do not use this for now!)
# test.qlty<-read.csv("C:/Users/frmendes/Desktop/Conoco Phillps/Meter Data/well_test2.csv")
# time<-strptime(test.qlty$DATETIME_TEST,format ="%d%b%Y:%T" )
# beg.time<-time - test.qlty$TEST_LENGTH*60*60
#
# df<-d.reg
# for(i in 1:length(beg.time))
# {
#   df<- filter(df, !DATE.TIME %within% interval(beg.time[i], time[i] ))
#   print(i)
# }
# d.reg<-df
#Remove Oct 6th and 7th#########
nrow(d.reg)
d.reg<-filter(d.reg, !DATE.TIME %within% interval('2016-10-06 11:00:00','2016-10-07 8:20:00'  ))
print(paste0("We have removed:", org.nrow-nrow(d.reg)))
print(paste0("We have removed:", org.nrow-nrow(d.reg),"rows"))
print(paste0("We have removed ", org.nrow-nrow(d.reg)," rows"))
d.mpm.tsep <- readRDS('d.mpm.tsep.rds')
sfx <- 'MOMENTS'
files.mat <- dir(path = dir.mat, pattern = sfx, all.files = FALSE,
full.names = TRUE)
ix.names <- 1:21
mu.names <- sapply(ix.names, function(x) paste0('MOMENT.MU.',x))
sig.names <- sapply(ix.names, function(x) paste0('MOMENT.SIG.',x))
skew.names <- sapply(ix.names, function(x) paste0('MOMENT.SKEW.',x))
kurt.names <- sapply(ix.names, function(x) paste0('MOMENT.KURT.',x))
coeff.names <- c(mu.names,sig.names,skew.names,kurt.names,'DATE.TIME')
################## read and rbind MOMENT files #####################
calculate.moments <- FALSE
if(calculate.moments){
d.moments <- readMat(files.mat[1]) %>% as.data.frame(stringsAsFactors=FALSE)
ptm <- proc.time()
for(file in files.mat[-1]){
d.temp <- readMat(file) %>% as.data.frame(stringsAsFactors=FALSE)
# d.moments <- rbind(d.moments, d.temp)
d.moments <- dplyr:: bind_rows(d.moments, d.temp)
}
proc.time() - ptm
names(d.moments) <- coeff.names
d.moments$DATE.TIME <- dmy_hms(d.moments$DATE.TIME) %>% floor_date('minute')
d.moments <- d.moments[, c('DATE.TIME', head(names(d.moments),-1))]
d.moments <- d.moments[!duplicated(d.moments$DATE.TIME),]
saveRDS(d.moments, 'd.moments.rds')
} else {
## join mpm.tsep and moments data
d.moments <- readRDS('d.moments.rds')
}
d.reg <- dplyr:: inner_join(d.moments, d.mpm.tsep, by='DATE.TIME')
### set aside test data for 6in pipe from Aug-01 to Aug-04, 13:00 pm
d.test.6in <- filter(d.reg, DATE.TIME %within% interval('2016-08-01 00:00:00', '2016-08-04 12:50:00' ))
### partition the 4in pipe data into Train/Validation and Test (10%, last 1 week)
d.4in <- filter(d.reg, DATE.TIME %within% interval('2016-08-04 14:00:00', tail(d.reg$DATE.TIME,1)))
ix.model <- 1:nrow(d.4in) # 1:floor(0.9 * nrow(d.4in))
d.model <- d.4in [ix.model,] ## use to train, cv
d.test.4in <- d.4in[-ix.model,] ## set aside for the fin
# saveRDS(d.test.6in, 'd.test.6in.rds')
# saveRDS(d.4in, 'd.4in.rds')
# saveRDS(d.model,'d.model.rds')
# saveRDS(d.test.4in,'d.test.4in.rds')
dev.new()
# d.model <- readRDS('d.model.rds')
i.plot = 40000:41000
plot(d.model$DATE.TIME[i.plot], d.model$MPM.STD.OIL.FLOW.RATE[i.plot],
main = 'MPM.STD.OIL.FLOW.RATE', type='l')
## sanity check that the d.model has the same data as d.reg
lines(d.reg$DATE.TIME[d.reg$DATE.TIME %in% d.model$DATE.TIME[i.plot]],
d.reg$MPM.STD.OIL.FLOW.RATE[d.reg$DATE.TIME %in% d.model$DATE.TIME[i.plot]],
type='l', col='green')
## splits % of the sample size
test.splits <- c(0.25, 0.20, 0.10)
# for(nsplit in test.splits[2]) {
nsplit <- test.splits[2]
n.train <- floor((1-nsplit) * nrow(d.model))
ix.train <- 1 : n.train
## set the seed to make the partition reproductible
########## ##### Choose predictor variables ##### ##### ##### #####
### 'MOMENT.MU.','MOMENT.SIG.', 'MOMENT.SKEW.','MOMENT.KURT.'
bool <- c(1,1,1,1) %>% as.logical
text <- c("MOMENT.MU","MOMENT.SIG","MOMENT.SKEW","MOMENT.KURT")
# for(n.moments in 1:4){
#  bool[1:n.moments] <-TRUE
sfx.x <- paste(text[bool],collapse="|")
sfx.save <- gsub('\\|(MOMENT)',"",sfx.x)  # %>% paste0(.,"_span",span,sep="")
sfx.x
sfx.save
names.x <- c(names(d.model)[grep(sfx.x,names(d.model))], 'TSEP.PROD.FLOWLINE.PRES', 'TSEP.PROD.FLOWLINE.TEMP')
#### Choose response variables#### Choose response variables#### Choose response variables
names.mpm.y <- c(
'MPM.STD.GAS.FLOW.RATE',
'MPM.STD.WATER.FLOW.RATE',
'MPM.STD.OIL.FLOW.RATE' )
names.tsep.y <- c(
'TSEP.PD.STD.GAS.FLOW.RATE',
'TSEP.PD.STD.WATER.FLOW.RATE',
'TSEP.PD.STD.OIL.FLOW.RATE'  )
####   ####   ####   ####   ####   ####
meter  <- 'tsep'
names.y <- names.tsep.y ##[1]
## get y.lim for plotting Results
d.ma <- rollmean(d.model[,names.y],241,align="right")
y.lim.high <- setNames(apply(d.ma[,names.y],2,max), names.y)
###################### Plot all meter data d.4in
ma.order <- 241 #moving average over 4 hours
y.4in.ma <- rollmean(d.4in[,c(names.tsep.y,names.mpm.y)],ma.order,align="right")
## skip the first ma.order-1 points
time.4in.ma <- d.4in$DATE.TIME %>%  tail(.,-(ma.order-1))
d.4in.ma <- data.frame(DATE.TIME=time.4in.ma, y.4in.ma)
y.lim.high.4in.mpm <- setNames(apply(d.4in[,c(names.mpm.y)],2,max), names.mpm.y)
y.lim.high.4in.tsep <- setNames(y.lim.high.4in.mpm, names.tsep.y)
y.lim.high.4in <- cbind(y.lim.high.4in.tsep, y.lim.high.4in.mpm)
y.lim.high.4in.mpm.ma <- setNames(apply(d.4in.ma[,c(names.mpm.y)],2,max), names.mpm.y)
# y.lim.high.4in.tsep.ma <- setNames(y.lim.high.4in.ma, names.tsep.y)
y.lim.high.4in.tsep.ma <-setNames(apply(d.4in.ma[,c(names.tsep.y)],2,max),names.tsep.y)
y.lim.high.4in.ma <- cbind(y.lim.high.4in.mpm.ma, y.lim.high.4in.tsep.ma)
### plot smoothed Tsep, MPM together
for(iname in names.tsep.y){
i.name.displ <-  gsub('.FLOW.RATE', '', iname)
component <- gsub('(^.+STD.)(.+$)', '\\2',i.name.displ)
ggplot(d.4in.ma,aes(x = DATE.TIME,y = d.4in.ma[,iname])) +
geom_line(color='green3',size=1) +
geom_line(data = d.4in.ma, aes(x = DATE.TIME,y = d.4in.ma[,grep(component, names.mpm.y, value=T)]),
color = 'black', size=0.55, alpha=0.8) +
ggtitle(paste0(i.name.displ,', Tsep(green), MPM(black)')) +
xlab('Date') + ylab(i.name.displ) +
ylim(0, y.lim.high.4in.ma[iname])
# ggsave(p, filename=paste0('Plot.Tsep.MPM_ma_',i.name.displ,'.png'), width = 7, height = 5)
}
## plot individual compnents for Tsep, MPM
for(iname in c(names.tsep.y,names.mpm.y)){
i.name.displ <-  gsub('.FLOW.RATE', '', iname)
component <- gsub('(^.+STD.)(.+$)', '\\2',i.name.displ)
if(grepl('MPM', i.name.displ)){
color <- 'black'
size <- 0.75
alpha <- 0.8
} else {
color <- 'green3'
size <- 1
alpha <- 1
}
p <- ggplot(d.4in.ma,aes(x = DATE.TIME,y = d.4in.ma[,iname])) +
geom_line(data = d.4in, aes(x = DATE.TIME,y = d.4in[,iname]),
color = color, size=0.5, alpha=0.25) +
geom_line(data = d.4in.ma, aes(x = DATE.TIME,y = d.4in.ma[,grep(component, names.mpm.y, value=T)]),
color = color, size=size, alpha=alpha) +
ggtitle(i.name.displ) +
xlab('Date') + ylab(i.name.displ) +
ylim(0, y.lim.high.4in[grep(component,iname)])
ggsave(p, filename=paste0('Plot.',i.name.displ,'.png'), width = 7, height = 5)
}
####### call function for One-Well-Out CV
wells <- table(d.model$WELL.ID) %>% sort(., decreasing=T) %>% dimnames %>% unlist %>% as.numeric
names.fit.well <- c('WELL.OUT', paste0('R2_', names.y), paste0('MAPE_', names.y),
paste0('RMSE_', names.y))
d.fit.well.out <- setNames(data.frame(matrix(ncol = length(names.fit.well), nrow = 0)),
names.fit.well)
time.train <- d.model$DATE.TIME[ix.train]
x.train <- d.model[ix.train, names.x] %>% as.matrix()
y.train <- d.model[ix.train, names.y] %>% as.matrix()
# use description to add any additonal info to the filename
description<- ""
calculate.cv.mfit = FALSE
if(calculate.cv.mfit){
ptm <- proc.time()
if(length(names.y)>1){
cv.mfit <- cv.glmnet(x.train, y.train , family='mgaussian')  ### multivariate
}else{
cv.mfit <- cv.glmnet(x.train, y.train )  ### single
}
plot(cv.mfit)
proc.time() - ptm
saveRDS(cv.mfit, paste0('cv.mfit_', toupper(meter),
'_nsplit',nsplit,'_',sfx.save,description,'.rds'))
} else {
cv.mfit <- readRDS(paste0('cv.mfit_', toupper(meter),
'_nsplit',nsplit,'_',sfx.save,description'.rds'))
}
if(calculate.cv.mfit){
ptm <- proc.time()
if(length(names.y)>1){
cv.mfit <- cv.glmnet(x.train, y.train , family='mgaussian')  ### multivariate
}else{
cv.mfit <- cv.glmnet(x.train, y.train )  ### single
}
plot(cv.mfit)
proc.time() - ptm
saveRDS(cv.mfit, paste0('cv.mfit_', toupper(meter),
'_nsplit',nsplit,'_',sfx.save,description,'.rds'))
} else {
cv.mfit <- readRDS(paste0('cv.mfit_', toupper(meter),
'_nsplit',nsplit,'_',sfx.save,description,'.rds'))
}
calculate.cv.mfit = FALSE
if(calculate.cv.mfit){
ptm <- proc.time()
if(length(names.y)>1){
cv.mfit <- cv.glmnet(x.train, y.train , family='mgaussian')  ### multivariate
}else{
cv.mfit <- cv.glmnet(x.train, y.train )  ### single
}
plot(cv.mfit)
proc.time() - ptm
saveRDS(cv.mfit, paste0('cv.mfit_', toupper(meter),
'_nsplit',nsplit,'_',sfx.save,description,'.rds'))
} else {
cv.mfit <- readRDS(paste0('Fit/cv.mfit_', toupper(meter),
'_nsplit',nsplit,'_',sfx.save,description,'.rds'))
}
## if peek into final tests
time.test.4in <- d.test.4in$DATE.TIME
x.test.4in <- d.test.4in[,names.x] %>% as.matrix()
y.test.4in <- d.test.4in[,names.y] %>% as.matrix()
time.test.6in <- d.test.6in$DATE.TIME
x.test.6in <- d.test.6in[,names.x] %>% as.matrix()
y.test.6in <- d.test.6in[,names.y] %>% as.matrix()
test.name <- 'model'
if(test.name=='4in'){
time.test <- time.test.4in
x.test <- x.test.4in
y.test <- y.test.4in
}else if(test.name=='6in'){
time.test <- time.test.6in
x.test <- x.test.6in
y.test <- y.test.6in
}
########## calculate prediction
yhat.cv <- predict.cv.glmnet(cv.mfit, x.test, s='lambda.1se')
yhat.cv[yhat.cv<0] <- 0
## quick look at the fit
if(length(names.y)>1){
for(i in 1:ncol(y.test)){
plot(y.test[,i], type='l', main=dimnames(y.test)[[2]][i],  col='green', lwd=2,
ylim=c(min(y.test[,i],yhat.cv[,i,]), max(y.test[,i],yhat.cv[,i,])))
lines(yhat.cv[,i,], type='l', col='blue', lwd=2)
}
}else{
plot(y.test[,i], type='l', main=dimnames(y.test)[[2]][i],  col='green', lwd=2,
ylim=c(min(y.test[,i],yhat.cv[,i,]), max(y.test[,i],yhat.cv[,i,])))
lines(yhat.cv[,i], type='l', col='blue', lwd=2)
}
time.train <- d.model$DATE.TIME[ix.train]
x.train <- d.model[ix.train, names.x] %>% as.matrix()
y.train <- d.model[ix.train, names.y] %>% as.matrix()
time.test <- d.model$DATE.TIME[-ix.train]
x.test <- d.model[-ix.train, names.x] %>% as.matrix()
y.test <- d.model[-ix.train, names.y] %>% as.matrix()
########## calculate prediction
yhat.cv <- predict.cv.glmnet(cv.mfit, x.test, s='lambda.1se')
yhat.cv[yhat.cv<0] <- 0
## quick look at the fit
if(length(names.y)>1){
for(i in 1:ncol(y.test)){
plot(y.test[,i], type='l', main=dimnames(y.test)[[2]][i],  col='green', lwd=2,
ylim=c(min(y.test[,i],yhat.cv[,i,]), max(y.test[,i],yhat.cv[,i,])))
lines(yhat.cv[,i,], type='l', col='blue', lwd=2)
}
}else{
plot(y.test[,i], type='l', main=dimnames(y.test)[[2]][i],  col='green', lwd=2,
ylim=c(min(y.test[,i],yhat.cv[,i,]), max(y.test[,i],yhat.cv[,i,])))
lines(yhat.cv[,i], type='l', col='blue', lwd=2)
}
## really close look at the fit
ii <- 1000:1100
ivar <- 1
plot(x=time.test[ii], y=y.test[ii,ivar], col='green', type='l', lwd=2,main=dimnames(y.test)[[2]][ivar],
ylim=c(min(y.test[ii,ivar],yhat.cv[ii,ivar,]), max(y.test[ii,ivar],yhat.cv[ii,ivar,])))
lines(x=time.test[ii], yhat.cv[ii,ivar,], col='blue', type='l',lwd=2)
#### smooth both test and prediction
d.y.test <- data.frame(DATE.TIME=time.test, y.test) # %>% f.loess(., span)
d.yhat.cv <- data.frame(DATE.TIME=time.test, yhat.cv) # %>% f.loess(., span)
names(d.yhat.cv) <- gsub('.\\d+$','',names(d.yhat.cv))
ma.order <- 241 #moving average over 4 hours
y.test.ma <- rollmean(d.y.test[,-1],ma.order,align="right")
yhat.cv.ma <- rollmean(d.yhat.cv[,-1],ma.order,align="right")
## skip the first ma.order-1 points
time.ma <- d.y.test$DATE.TIME %>%  tail(.,-(ma.order-1))
d.y.test.ma <- data.frame(DATE.TIME=time.ma, y.test.ma)
d.yhat.cv.ma <- data.frame(DATE.TIME=time.ma, yhat.cv.ma)
d.y.test <- d.y.test.ma
d.yhat.cv <- d.yhat.cv.ma
#############################################
# add 'mpm' to compare performance
y.mpm <- rollmean(d.model[,names.mpm.y],ma.order,align="right")
## skip the first ma.order-1 points to align averaged y.mpm and time
time.mpm <- d.model$DATE.TIME %>%  tail(.,-(ma.order-1))
d.mpm <- data.frame(DATE.TIME=time.mpm, y.mpm)
d.mpm <- filter(d.mpm, DATE.TIME %in% d.y.test$DATE.TIME)
##### Rsquared
Rsquared<-list()
MAPE <- list()
RMSE <- list()
names.fit <- c('R2.acoust', 'MAPE.acoust', 'RSME.acoust', 'R2.mpm', 'MAPE.mpm', 'RSME.mpm' )
d.fit <- setNames(data.frame(matrix(ncol = length(names.fit)+1, nrow = 0)),
c('COMPONENT', names.fit))
for(iname in names(d.y.test[-which(names(d.y.test) %in%
c('DATE.TIME', 'WELL.ID'))])){
component <- gsub('(^.+STD.)(.+$)', '\\2',iname)
## Rsquared
fit.yhat <- f.measure.error(d.y.test[ ,iname],
d.yhat.cv [ ,iname]) %>% as.list %>% data.frame
fit.mpm <-  f.measure.error(d.y.test[ ,iname],
d.mpm [ ,grep(component, names(d.mpm), value=T)]) %>% as.list %>% data.frame
names(fit.yhat) <- paste0(names(fit.yhat),'.acoust')
names(fit.mpm) <- paste0(names(fit.mpm),'.mpm')
d.fit.temp <- data.frame(COMPONENT=iname) %>% cbind(., fit.yhat, fit.mpm)
d.fit <- rbind(d.fit, d.fit.temp)
error<-sum((d.y.test[ ,iname] - d.yhat.cv [ ,iname])^2)
tss <- sum((d.y.test[ ,iname] - mean(d.y.test[,iname]))^2)
Rsquared[[iname]] <- 1-(error/tss)
RMSE[[iname]] <- sqrt(mean((d.y.test[ ,iname] - d.yhat.cv [ ,iname])^2))
## MAPE
err.mape <- sum(abs((d.y.test[ ,iname] - d.yhat.cv [ ,iname])))
MAPE[[iname]] <- err.mape / sum(d.y.test[ ,iname]) *100
}
Rsquared
write.csv(d.fit, paste0('D.FIT/remove6th7thOct',
nsplit,'_Compare.', toupper(meter),'_',sfx.save,'.csv'))
####### PLOT and SAVE
d.fit
write.csv(d.fit, paste0('D.FIT/remove6th7thOct',
nsplit,'_Compare.', toupper(meter),'_',sfx.save,'.csv'))
####### PLOT and SAVE
####### PLOT and SAVE
for(iname in names(d.y.test[-which(names(d.y.test) %in%
c('DATE.TIME', 'WELL.ID'))])){
i.name.displ <-  gsub('.FLOW.RATE', '', iname)
component <- gsub('(^.+STD.)(.+$)', '\\2',i.name.displ)
fit.row <- filter(d.fit, d.fit$COMPONENT==iname)
p <- ggplot(d.y.test,aes(x = DATE.TIME,y = d.y.test[,iname])) +
geom_line(color='green',size=1.5) +
geom_line(data = d.yhat.cv, aes(x = DATE.TIME,y = d.yhat.cv[,iname]),
color = 'blue', size=1.5) +
geom_ribbon(aes(ymin=pmax(0,(d.yhat.cv[,iname]-RMSE[[iname]])),
ymax=d.yhat.cv[,iname]+RMSE[[iname]]), fill='blue', alpha=0.1) +
geom_line(data = d.mpm, aes(x = DATE.TIME,y = d.mpm[,grep(component, names(d.mpm), value=T)]),
color = 'black', size=0.75) +
ggtitle(paste0(i.name.displ,
', R2 = ' , round(fit.row$R2.acoust, digits=2),
'/',  round(fit.row$R2.mpm, digits=2),
', MAPE = ' , round(fit.row$MAPE.acoust, digits=1),
'/',  round(fit.row$MAPE.mpm, digits=1),
', RMSE = ' , round(fit.row$RMSE.acoust, digits=0),
'/',  round(fit.row$RMSE.mpm, digits=0))) +
xlab('') + ylab(i.name.displ) + ylim(0, y.lim.high[iname])
ggsave(p, filename=paste0('Plots/remove6th7thOct',i.name.displ,'_split',
nsplit,'_Compare.',sfx.save,'.png'), width = 7, height = 5)
}
install.packages("polydect")
install.packages("HD")
library(disp2D)
library(geometry)
library(mvtnorm)
sigma1 = matrix(c(0.912897,1.092679,1.092679,1.336440),byrow=TRUE,ncol=2)
sigma2 = sigma1 + diag(1,ncol=2,nrow=2)
A = rmvnorm(200,mean=rep(0,2),sigma=sigma1)
B = rmvnorm(200,mean=rep(0,2),sigma=sigma2)
install.packages("disp2D")
install.packages("geometry")
library(disp2D)
library(geometry)
library(mvtnorm)
sigma1 = matrix(c(0.912897,1.092679,1.092679,1.336440),byrow=TRUE,ncol=2)
sigma2 = sigma1 + diag(1,ncol=2,nrow=2)
A = rmvnorm(200,mean=rep(0,2),sigma=sigma1)
B = rmvnorm(200,mean=rep(0,2),sigma=sigma2)
r=.1
prob = probA = probB = rep(1/200,200)
HA = exactHausdorff(A,probA,r)
HB = exactHausdorff(B,probB,r)
plot(HA$distance, cumsum(HA$probability), type = "l", xlab = "",
ylab = "DF", xlim = range(c(HA,HB)))
lines(HB$distance, cumsum(HB$probability), lty = 2)
d1 = simplex(A,bootstrap=TRUE,nresamples=100)
HA
probB
A
plot(A,type='l')
plot(probB)
HA = exactHausdorff(A,B)
HA = exactHausdorff(A,B,r)
plot(HA$distance, cumsum(HA$probability), type = "l", xlab = "",
ylab = "DF", xlim = range(c(HA,HB)))
lines(HB$distance, cumsum(HB$probability), lty = 2)
plot(y.test[,3],type='l')
plot(d.mpm$MPM.STD.OIL.FLOW.RATE,type='l')
lines(d.y.test,col= 'red')
plot(d.y.test$TSEP.PD.STD.OIL.FLOW.RATE)
plot(d.y.test$TSEP.PD.STD.OIL.FLOW.RATE,type='l')
lines(d.yhat.cv$TSEP.PD.STD.OIL.FLOW.RATE,col = 'red')
lines(d.mpm$MPM.STD.OIL.FLOW.RATE,col = green')
lines(d.mpm$MPM.STD.OIL.FLOW.RATE,col = 'green')
HD<-function(X,Y){
hd=0
n1<-length(X)
n2<-length(Y)
d1<-c()
d2<-c()
if(n1*n2==0) hd<- -1
else{
stopifnot(is.numeric(X))
stopifnot(is.numeric(Y))
for (i in 1:n1)	d1[i]<-min(abs(X[i]-Y))
for (i in 1:n2)     d2[i]<-min(abs(Y[i]-X))
hd=max(max(d1),max(d2))
}
hd
}
HD(d.y.test$TSEP.PD.STD.OIL.FLOW.RATE,d.yhat.cv$TSEP.PD.STD.OIL.FLOW.RATE)
HD(d.y.test$TSEP.PD.STD.OIL.FLOW.RATE,d.mpm$MPM.STD.OIL.FLOW.RATE)
lines(d.mpm$MPM.STD.OIL.FLOW.RATE,col = 'blue')
HD(d.y.test$TSEP.PD.STD.WATER.FLOW.RATE,d.yhat.cv$TSEP.PD.STD.WATER.FLOW.RATE)
HD(d.y.test$TSEP.PD.STD.WATER.FLOW.RATE,d.mpm$MPM.STD.OIL.FLOW.RATE)
HD(d.y.test$TSEP.PD.STD.WATER.FLOW.RATE,d.mpm$MPM.STD.WATER.FLOW.RATE)
HD(d.y.test$TSEP.PD.STD.WATER.FLOW.RATE,d.mpm$MPM.STD.WATER.FLOW.RATE)
HD(d.y.test$TSEP.PD.STD.GAS.FLOW.RATE,d.yhat.cv$TSEP.PD.STD.GAS.FLOW.RATE)
HD(d.y.test$TSEP.PD.STD.GAS.FLOW.RATE,d.mpm$MPM.STD.GAS.FLOW.RATE)
plot(d.y.test$TSEP.PD.STD.GAS.FLOW.RATE,type='l')
lines(d.yhat.cv,col = 'green')
lines(d.yhat.cv$TSEP.PD.STD.GAS.FLOW.RATE,col = 'green')
